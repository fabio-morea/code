---
title: "consensus ML on LFR"
author: "Fabio Morea"
date: "2023-065-23"
 
output:
  pdf_document: default
  html_document: default
---

# knitr::purl('fig_consensus_LFR.Rmd') #to create script

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE)
# to extract R code only for faster run
#knitr::purl("fig_consensus_LFR.Rmd")
```

```{r load libraries, include=FALSE}
library(igraph)
library(tidyverse)
library(gridExtra)
library(ggpubr)
library(aricode) # NMI 

#install.packages("remotes")
#remotes::install_github("schochastics/netUtils")
library(netUtils)
library(VGAM)

library(devtools)  
#devtools::install_github("fabio-morea/CCD", force = TRUE)
library(CCD)
print("packages loaded")

```




```{r}
make_benchmark_network <- function(n,
                                   average_degree,
                                   max_degree,
                                   min_community,
                                   max_community,
                                   mu,
                                   tau1,
                                   tau2, 
                                   max_trials=100) {
    err_check <- TRUE
    gLFR <- NULL
    trial <- 0
    while (err_check & trial < max_trials) {
        trial <- trial + 1
        tryCatch(
            gLFR <- sample_lfr(
                n = n,
                average_degree = average_degree,
                max_degree = max_degree,
                min_community = min_community,
                max_community = max_community,
                mu = mu ,
                tau1 = tau1,
                tau2 = tau2
            ),error = function(e)NULL)
        if (is.null(gLFR)) {
            print(paste("unable to generate netowork - trial", trial))
        } else {
            err_check <- FALSE
        }
    }
    if (trial > max_trials) {
        print(paste("unsuccessfully tried",max_trials,"times. Please provide a different set of params"))
        return(-1)
    } else {
        return (gLFR)
    }
    
}

testG <- make_benchmark_network(
            n = 1000,
            average_degree = 5,
            max_degree = 20,
            min_community = 5,
            max_community = 50,
            mu = 0.2,
            tau1 = 3.0,
            tau2 = 2.0
            
        )
print(testG)
```


  ```{r}

load_benchmark_network <- function(mui, path = path, verbose = FALSE) {
    filename = paste0(path, mui, ".gml")
    g <- read_graph(filename, format = "gml")
    
    g<-as.undirected( g , mode = 'each')
    g<-igraph::simplify(g, remove.multiple = TRUE, edge.attr.comb = igraph_opt("sum"))
    
    V(g)$comm_built_in <-  V(g)$community
    V(g)$core <- coreness(g)
    V(g)$str <- strength(g)
    V(g)$name <- paste0("V" , V(g)$name)
    E(g)$w <- 1.0
    E(g)$ww <- 1.0
    E(g)$weight <- 1.0
    
    # print
    if (verbose == TRUE) {
        print(paste0("Loaded benchmark network ", path, mui, ".gml"))
        print(paste("Giant component size :", length(V(g)$community)))
        print(paste("Built-in communities: ", max(V(g)$community)))
        mod <- round( modularity(g, array(V(g)$community+1) ), digits = 4)
        print(paste("Modularity of built-in communities: ", mod))
    } 
    return(g)
}
  ```


```{r}

recursive_consensus <- function(M, threshold , met, t) {
  j = 1
  
  while (j <= 10) {
    co_occ_matrix <-  CCD::normalized_co_occurrence((M))
    
    # all entries of co occurrenc ematrix below a threshold are set to zero
    co_occ_matrix[co_occ_matrix < threshold] <- 0
    
    g2 <- graph_from_adjacency_matrix(
        co_occ_matrix,
        diag = FALSE,
        weighted = TRUE,
        mode = "upper"
      )
    
    #print(paste("iteration", j))
    #print(table(E(g2)$weight))
    
    cons_communities_2 <- CCD::find_communities(g2, method = met, verbose = FALSE)
    
    
    if (length(table(E(g2)$weight)) == 1) {
      print("reached consensus")
      #print(length(table(E(g2)$weight)))
      #print(j)
      return(cons_communities_2)
    } else {
      print(paste("iteration", j))
      #print(g2)
    } 
    
    M  <- CCD::find_communities_repeated (g2, n_trials = t, method = met)
    
    j <- j + 1
    
    
  }
  print("reached max iterations")
  return(cons_communities_2)
}

```




```{r}

path <- "./benchmark/LFR/LFR_benchmark_"
mui = seq(5, 70, 10)
n_repetitions<-3
n_trials = 50
threshold = 0.60
#resol = c(0.99)
methods = c('LV', 'LD', 'LP', 'IM', 'WT')
method_base = 'LV'
summary_n_trials  <- data.frame()
nc_builtin <- c()

      uncertain_nodes <- 0.0
      uncertainty_q10 <- 0.0
      uncertainty_q50 <- 0.0
      uncertainty_q90 <- 0.0

for (mu in mui) {
  #print(paste("MU = ", mu))
  for (j in 1:n_repetitions) {
    print(paste("REPETITION ", j))
    #create a network 
    #      #g <- load_benchmark_network(mui = mu,path = path,verbose = FALSE)

    g <- make_benchmark_network(
      n = 500,
      average_degree = 10,
      max_degree = 40,
      min_community = 20,
      max_community = 50,
      mu = mu / 100,
      tau1 = 2.0,
      tau2 = 1.5
    )
    V(g)$name <- paste0("V", 1:vcount(g))
    E(g)$weight <- 1.0
    E(g)$w <- 1.0
    V(g)$comm_built_in <- V(g)$membership
    V(g)$community <- V(g)$membership
    mu_built_in = round(empirical_mu(g), 3)
    nc_builtin <- max(V(g)$comm_built_in)
    
    for (method_base in methods) {
      print(paste('mu: ', mu, '**** method : ', method_base))
      method <- paste0(method_base, '_ST')
      
      M <- data.frame(name = V(g)$name)
      for (i in 1:n_trials) {
        gs <-igraph::permute(g, sample(1:vcount(g), size = vcount(g), replace = FALSE))
        comms <- CCD::find_communities(gs, method = method)
        # order() function to get the communities found on gs in the order they appear in g
        V(g)$community <-
          comms$membership[order(match(comms$name, V(g)$name))]
        
        nmi <-
          aricode::NMI(as.factor(V(g)$community),
                       as.factor(V(g)$comm_built_in))
        mu_emp <- round(empirical_mu(g), 3)
        nc_norm <-
          round(sum(table((
            V(g)$community
          )) > 1) / nc_builtin, 4)
        met <- method
      results_iteration <-data.frame(mu, mu_built_in, mu_emp, met, j, nmi, nc_norm, uncertain_nodes, uncertainty_q10, uncertainty_q50, uncertainty_q90)
        summary_n_trials <-
          rbind(summary_n_trials , results_iteration)
        
        comm_labeled <-data.frame(name = V(gs)$name,memb = comms$membership)
        M <- inner_join(M, comm_labeled, by = "name")
        colnames(M) <- c("name", seq(1:i))
        
      }
      
      method <- paste0(method_base, '_consRec')
      commsRC <- recursive_consensus (M,
                                      threshold = threshold ,
                                      met = method_base,
                                      t = n_trials)
      
      V(g)$community <-
        commsRC$membership[order(match(commsRC$names, V(g)$name))]
      nmi <-
        aricode::NMI(as.factor(V(g)$community), as.factor(V(g)$comm_built_in))
      mu_emp <- round(empirical_mu(g), 3)
      nc_norm <-
        round(sum(table((
          V(g)$community
        )) > 1) / nc_builtin, 4)
      met <- method
      results_iteration <-data.frame(mu, mu_built_in, mu_emp, met, j, nmi, nc_norm, uncertain_nodes, uncertainty_q10, uncertainty_q50, uncertainty_q90)
      summary_n_trials <-
        rbind(summary_n_trials , results_iteration)
      
      
      
      nco <- CCD::normalized_co_occurrence(M)
      method <- paste0(method_base, '_CCD_p06')
      commsCCD <- CCD::consensus_communities(nco, p = 0.6)
      V(g)$community <- commsCCD$cons_comm_label[order(match(commsCCD$name, V(g)$name))]
      uncertain_nodes <- sum(commsCCD$gamma>0)/vcount(g)
      uncertainty_q10 <- round(quantile(commsCCD$gamma[ commsCCD$gamma >0], 0.10),6)
      uncertainty_q50 <- round(quantile(commsCCD$gamma[ commsCCD$gamma >0], 0.50),6)
      uncertainty_q90 <- round(quantile(commsCCD$gamma[ commsCCD$gamma >0], 0.90),6)
      nmi <- aricode::NMI(as.factor(V(g)$community), as.factor(V(g)$comm_built_in))
      mu_emp <- round(empirical_mu(g), 3)
      nc_norm <- round(sum(table((V(g)$community)) > 1) / nc_builtin, 4)
      met <- method
      results_iteration <-data.frame(mu, mu_built_in, mu_emp, met, j, nmi, nc_norm, uncertain_nodes, uncertainty_q10, uncertainty_q50, uncertainty_q90)
      summary_n_trials <-rbind(summary_n_trials , results_iteration)
      
      
      method <- paste0(method_base, '_CCD_p08')
      commsCCD <- CCD::consensus_communities(nco, p = 0.8)
      V(g)$community <-commsCCD$cons_comm_label[order(match(commsCCD$name, V(g)$name))]
      uncertain_nodes <- sum(commsCCD$gamma>0)/vcount(g)
      uncertainty_q10 <- round(quantile(commsCCD$gamma[ commsCCD$gamma >0], 0.10),6)
      uncertainty_q50 <- round(quantile(commsCCD$gamma[ commsCCD$gamma >0], 0.50),6)
      uncertainty_q90 <- round(quantile(commsCCD$gamma[ commsCCD$gamma >0], 0.90),6)
      
      nmi <- aricode::NMI(as.factor(V(g)$community), as.factor(V(g)$comm_built_in))
      mu_emp <- round(empirical_mu(g), 3)
      nc_norm <- round(sum(table((V(g)$community)) > 1) / nc_builtin, 4)
      met <- method
      results_iteration <-data.frame(mu, mu_built_in, mu_emp, met, j, nmi, nc_norm, uncertain_nodes, uncertainty_q10, uncertainty_q50, uncertainty_q90)
      summary_n_trials <-rbind(summary_n_trials , results_iteration)
      
            method <- paste0(method_base, '_CCD_p08g')
      #commsCCD <- CCD::consensus_communities(nco, p = 0.8)
      commsCCD[commsCCD$size == 1] <- 0
      V(g)$community <-commsCCD$cons_comm_label[order(match(commsCCD$name, V(g)$name))]
      uncertain_nodes <- sum(commsCCD$gamma>0)/vcount(g)
      uncertainty_q10 <- round(quantile(commsCCD$gamma[ commsCCD$gamma >0], 0.10),6)
      uncertainty_q50 <- round(quantile(commsCCD$gamma[ commsCCD$gamma >0], 0.50),6)
      uncertainty_q90 <- round(quantile(commsCCD$gamma[ commsCCD$gamma >0], 0.90),6)
      
      nmi <- aricode::NMI(as.factor(V(g)$community), as.factor(V(g)$comm_built_in))
      mu_emp <- round(empirical_mu(g), 3)
      nc_norm <- round(sum(table((V(g)$community)) > 1) / nc_builtin, 4)
      met <- method
      results_iteration <-data.frame(mu, mu_built_in, mu_emp, met, j, nmi, nc_norm, uncertain_nodes, uncertainty_q10, uncertainty_q50, uncertainty_q90)
      summary_n_trials <-rbind(summary_n_trials , results_iteration)
      
      
      
      uncertain_nodes <- 0.0
      uncertainty_q10 <- 0.0
      uncertainty_q50 <- 0.0
      uncertainty_q10 <- 0.0
    }
  }
}

summary_n_trials  %>% write_csv('./results/results_cons_comm_detection_06_08_G.csv')

 
```
# make benchmarks

```{r}


for (mu in seq(5,55,5)){
    for (t in 1:10){
      print(paste(mu, t))
        gfilename <- paste0("./benchmark/LFR/LFR_benchmark_1000_5_50_20_50_2_3_mu", mu, "_t",t,"_.gml")
        g<-0
        g <- make_benchmark_network(
            n = 1000,
            average_degree = 5,
            max_degree = 50,
            min_community = 20,
            max_community = 50,
            mu = mu / 100,
            tau1 = 2,
            tau2 = 3
        )
        V(g)$name <- 1:vcount(g)
        write_graph(g, gfilename, format = "graphml")
        test <- read_graph(gfilename, format = "graphml")
    }
}



```

```{r}
nc_builtin <- max(V(g)$membership)

      
commsCCD <- CCD::consensus_community_detection(g, p=0.6, group_outliers = FALSE)
V(g)$community <- commsCCD$membership[order(match(commsCCD$name, V(g)$name))]
nc <- sum(table((V(g)$community)) > 1)
nc_norm <- round( nc/ nc_builtin, 4)
print(paste(nc, nc_builtin, nc_norm))


commsCCD <- CCD::consensus_community_detection(g, p=0.8, group_outliers = FALSE)
V(g)$community <- commsCCD$membership[order(match(commsCCD$name, V(g)$name))]
nc <- length(unique(V(g)$community))
nc_norm <- round( nc/ nc_builtin, 4)
print(paste("comms: ",nc, nc_builtin, nc_norm))


commsCCD$membership[commsCCD$comm_size == 1] <- 0 #group single node communities
V(g)$community <- commsCCD$membership[order(match(commsCCD$name, V(g)$name))]
nc <- length(unique(V(g)$community))
nc_norm <- round( nc/ nc_builtin, 4)
print(paste(nc, nc_builtin, nc_norm))


```
 
## performance depends on the network topology
QUI STIAMO USANDO LE RETI LFR PRECOSTITUITE, LE STESSE DEL PRIMO PAPER
CREATE IN PYTHON CON 

n = 1000
tau1 = 2
tau2 = 3
average_degree=5
max_degree = 50
min_community=  20
max_community = 50

```{r}
df <- read_csv('./results/results_cons_comm_detection_LFR_base.csv')
df <- df %>% 
   mutate(mu_bi_int =  round(mu_built_in *2 ,1)/2)%>%
   mutate(alg = substr(met, 1,2)) %>%
   mutate(cons = substr(met, 4,15)) %>%
   filter(mu_built_in <=0.5)


png('figure12.png',width = 1600, height = 800)
shapes <- c(6,2,0,21, 21)
colorss <- c("darkgreen", "purple", "lightgray") 

df1<-df |>
  select(mu,  alg, cons,nmi, nc_norm) |>
  filter(cons %in% c('CCD_p06', 'ST', 'consRec') ) |>
  
  pivot_longer(cols = -c(mu, alg, cons), 
                 names_to = "variable", 
                 values_to = "value")|>
  group_by(mu, alg, cons, variable)|>
    summarize(
    v_mean = mean(value),
    v_lower_quantile = quantile(value, 0.20),
    v_upper_quantile = quantile(value, 0.80)
  ) |>
  mutate(method = case_when(
    cons == 'CCD_p06' ~ 'CCD Aggregate p = 0.6',
    cons == 'ST' ~ 'single trials',
    cons == 'consRec' ~ 'Recursive Consensus',
    TRUE ~ as.character(cons)
  ))

p12<-df1|>filter(variable %in% c( 'nmi', 'nc_norm'))|>
  ggplot(aes(x = mu, y = v_mean, group = method, color = method)) +
  geom_hline(yintercept = 1.0)+  
  geom_point() +
  geom_line()+
  #geom_errorbar(data = df1 |> filter(cons != 'ST'),             aes(ymin = v_lower_quantile, ymax = v_upper_quantile),width = 1.0) + 
  geom_ribbon( data = df1 |> filter(cons == 'ST'), 
               aes(ymin = v_lower_quantile, ymax = v_upper_quantile),alpha = 0.2, color = NA )+
      scale_shape_manual( values = shapes)+
  scale_color_manual( values = colorss)+
  facet_grid( variable ~ alg, scales = 'free_y')+
  theme_light() + 
  theme(aspect.ratio = 1)  +
  theme(legend.position="right")+ 
  labs( x = "mu", y = " ")+ 
   theme(
    legend.position = "top",    # Place the legend on top
    legend.box = "horizontal"   # Display the legend items in a single line
  )
 
p12
dev.off()
p12
```

# read data from file

```{r}
library(tidyverse)
library(ggpubr)

df <- read_csv('./results/results_cons_comm_detection__ __06_08_G.csv')
df <- df %>% 
   mutate(mu_bi_int =  round(mu_built_in *2 ,1)/2)%>%
   mutate(alg = substr(met, 1,2)) %>%
   mutate(cons = substr(met, 4,15)) %>%
   filter(mu_built_in <=0.5)
#table(df$mu_bi_int)
table(df$mu)






```

```{r}
dfo <- df |>   filter(cons %in% c('CCD_p06', 'CCD_p08', 'CCD_p08g') ) 
df|> ggplot(aes(x=mu_emp, y=nmi, color = cons))+geom_point() + geom_line() + facet_grid(~ alg)
df|> ggplot(aes(x=mu_emp, y=nc_norm, color = cons))+geom_point() + geom_line() +  facet_grid(~ alg)
```


#plot 11 compare the 3 methods for outliers

```{r}

long_df <- df %>%   
    pivot_longer(cols = c('nmi', 'nc_norm'), 
                 names_to = "variable", 
                 values_to = "value") %>%
    select(mu, mu_emp,mu_bi_int, alg, met, cons, variable, value)  

table(long_df$mu)

shapes <- c(6,2,0,21, 21)
colorss <- c("black","darkgreen","purple" )  

long_df |>
  filter(cons %in% c('CCD_p06', 'CCD_p08', 'CCD_p08g') ) |>
    mutate(cons_label = case_when(
    cons == 'CCD_p06' ~ 'Aggregate p = 0.6',
    cons == 'CCD_p08' ~ 'Highlight p = 0.8',
    cons == 'CCD_p08g' ~ 'Group p = 0.8',
    TRUE ~ as.character(cons)
  ))|>
  ggplot(aes(x = mu, y = value, group = met, color = cons_label)) + 
  geom_vline(xintercept = 0.5, color = 'red', linetype = "dashed")+
  geom_hline(yintercept = 1, color = 'darkgreen', linewidth = 0.5, linetype = "dashed")+
  facet_grid( variable ~ alg, scales = 'free_y')+
  geom_point( size = 1.5) +
  geom_line( size = .5) +
  theme_light() +  
  theme(aspect.ratio = 1.0) +
  scale_shape_manual(title, values = shapes)+
  scale_color_manual(title, values = colorss)+
  labs(color = "strategies for outliers") +  # Set the legend title
 theme(
    legend.position = "top",    # Place the legend on top
    legend.box = "horizontal"   # Display the legend items in a single line
  )
  
```


```{r}
png('figure11.png',width = 1600, height = 800)

shapes <- c(6,2,0,21, 21)
colorss <- c("red","blue","darkgreen") 
title <- "Strategy for outliers"
df1<-df |>
  select(mu, mu_emp, met, j, alg, cons,  nmi, nc_norm, uncertain_nodes) |>
  mutate(mu = mu/100)|>
  filter(cons %in% c('CCD_p06', 'CCD_p08', 'CCD_p08g') ) |>
  pivot_longer(cols = -c(mu, met, j, alg, cons), 
                 names_to = "variable", 
                 values_to = "value")|>
  group_by(mu, met, j, alg, cons, variable)|>
    summarize(
    v_mean = mean(value),
    v_lower_quantile = quantile(value, 0.20),
    v_upper_quantile = quantile(value, 0.80)
  ) |>
  filter(cons %in% c('CCD_p06', 'CCD_p08', 'CCD_p08g') ) |>
    mutate(method = case_when(
    cons == 'CCD_p06' ~ 'Aggregate p = 0.6',
    cons == 'CCD_p08' ~ 'Highlight p = 0.8',
    cons == 'CCD_p08g' ~ 'Group p = 0.8',
    TRUE ~ as.character(cons)
  ))

p1<-df1 %>% filter(variable %in% c( 'nmi', 'nc_norm'))|>
  ggplot(aes(x = mu, y = v_mean, group = method, color = method)) +
  geom_hline(yintercept = 1.0)+  
  geom_point(size = 2) +  
  geom_line(linewidth=1)+
  geom_errorbar(aes(ymin = v_lower_quantile, ymax = v_upper_quantile),width = 0.0) + 
  geom_ribbon(
    aes(ymin = v_lower_quantile, ymax = v_upper_quantile, fill = method),
    alpha = 0.1,
    color = NA)+
  facet_grid(  variable  ~ alg, scales = 'free')+
  theme_light() + 
  theme(aspect.ratio = 1)  +
  theme(legend.position="right")+ 
  #  scale_shape_manual( values = shapes)+
  #scale_color_manual( values = colorss)+
  labs( x = "mu", y = " ")+ 
   theme(
    legend.position = "top",    # Place the legend on top
    legend.box = "horizontal"   # Display the legend items in a single line
  )
 
p1

dev.off()

p1

```

```{r}
png('figure11.png',width = 1600, height = 800)
shapes <- c(6,2,0,21, 21)
colorss <- c("red","blue","darkgreen") 
title <- "Strategy for outliers"

df1<-df |>
  select(mu,  alg, cons, nmi, nc_norm) |>
  #filter(alg == 'WT')|>
  filter(cons %in% c('CCD_p06', 'CCD_p08', 'CCD_p08g') ) |>
  pivot_longer(cols = -c(mu,  alg, cons), 
                 names_to = "variable", 
                 values_to = "value")|>
  group_by(mu, alg, cons, variable)|>
    summarize(
    v_mean = mean(value),
    v_lower_quantile = quantile(value, 0.20),
    v_upper_quantile = quantile(value, 0.80)
  ) |>
    mutate(method = case_when(
    cons == 'CCD_p06' ~ 'Aggregate p = 0.6',
    cons == 'CCD_p08' ~ 'Highlight p = 0.8',
    cons == 'CCD_p08g' ~ 'Group p = 0.8',
    TRUE ~ as.character(cons)
  ))

p11<-df1|>filter(variable %in% c( 'nmi', 'nc_norm'))|>
  ggplot(aes(x = mu, y = v_mean, group = method, color = method)) +
  geom_hline(yintercept = 1.0)+  
  geom_point() +
  geom_line()+
  #geom_errorbar(data = df1 |> filter(cons != 'ST'),             aes(ymin = v_lower_quantile, ymax = v_upper_quantile),width = 1.0) + 
  geom_ribbon( data = df1 |> filter(cons == 'ST'), 
               aes(ymin = v_lower_quantile, ymax = v_upper_quantile),alpha = 0.2, color = NA )+
      scale_shape_manual( values = shapes)+
  scale_color_manual( values = colorss)+
  facet_grid( variable ~ alg, scales = 'free_y')+
  theme_light() + 
  theme(aspect.ratio = 1)  +
  theme(legend.position="right")+ 
  labs( x = "mu", y = " ")+ 
   theme(
    legend.position = "top",    # Place the legend on top
    legend.box = "horizontal"   # Display the legend items in a single line
  )
 
p11
dev.off()
p11
```

#plot 12 compare performance against ST and consREC



```{r}
png('figure12.png',width = 1600, height = 800)
shapes <- c(6,2,0,21, 21)
colorss <- c("darkgreen", "purple", "lightgray") 

df1<-df |>
  select(mu,  alg, cons,nmi, nc_norm) |>
  filter(cons %in% c('CCD_p06', 'ST', 'consRec') ) |>
  
  pivot_longer(cols = -c(mu, alg, cons), 
                 names_to = "variable", 
                 values_to = "value")|>
  group_by(mu, alg, cons, variable)|>
    summarize(
    v_mean = mean(value),
    v_lower_quantile = quantile(value, 0.20),
    v_upper_quantile = quantile(value, 0.80)
  ) |>
  mutate(method = case_when(
    cons == 'CCD_p06' ~ 'CCD Aggregate p = 0.6',
    cons == 'ST' ~ 'single trials',
    cons == 'consRec' ~ 'Recursive Consensus',
    TRUE ~ as.character(cons)
  ))

p12<-df1|>filter(variable %in% c( 'nmi', 'nc_norm'))|>
  ggplot(aes(x = mu, y = v_mean, group = method, color = method)) +
  geom_hline(yintercept = 1.0)+  
  geom_point() +
  geom_line()+
  #geom_errorbar(data = df1 |> filter(cons != 'ST'),             aes(ymin = v_lower_quantile, ymax = v_upper_quantile),width = 1.0) + 
  geom_ribbon( data = df1 |> filter(cons == 'ST'), 
               aes(ymin = v_lower_quantile, ymax = v_upper_quantile),alpha = 0.2, color = NA )+
      scale_shape_manual( values = shapes)+
  scale_color_manual( values = colorss)+
  facet_grid( variable ~ alg, scales = 'free_y')+
  theme_light() + 
  theme(aspect.ratio = 1)  +
  theme(legend.position="right")+ 
  labs( x = "mu", y = " ")+ 
   theme(
    legend.position = "top",    # Place the legend on top
    legend.box = "horizontal"   # Display the legend items in a single line
  )
 
p12
dev.off()
p12
```



```{r}

df1 <- df %>%   
    pivot_longer(cols = c('nmi', 'nc_norm'), 
                 names_to = "variable", 
                 values_to = "value") %>%
    select(mu, mu_emp, alg, met, cons, variable, value)  


shapes <- c(6,2,0,21, 21)
colorss <- c("blue","darkgreen","red", "gray", "black")  
title <- "strategies for outliers"
df1 |>
  filter(cons %in% c('CCD_p06', "ST", "consLF") ) |>
    mutate(cons_label = case_when(
    cons == 'CCD_p06' ~ 'CCD Aggregate p = 0.6',
    cons == 'ST' ~ 'single trial ',
    cons == 'CCD_p08g' ~ 'Group p = 0.8',
    TRUE ~ as.character(cons)
  ))|>
  ggplot(aes(x = mu, y = value, group = cons_label, color = cons_label)) + 
  geom_vline(xintercept = 0.5, color = 'red', linetype = "dashed")+
  geom_hline(yintercept = 1, color = 'darkgreen', linewidth = 0.5, linetype = "dashed")+
  facet_grid( variable ~ alg, scales = 'free_y')+
  geom_point( size = 1.5) +
  geom_line( size = 1) +
  geom_smooth()+
  theme_light() +  
  theme(aspect.ratio = 1.0) +
  scale_shape_manual(title, values = shapes)+
  scale_color_manual(title, values = colorss)+
 theme(
    legend.position = "top",    # Place the legend on top
    legend.box = "horizontal"   # Display the legend items in a single line
  )
  
```


 

```{r}
df |> 
    filter(cons %in% c('CCD_p06', 'CCD_p08', 'CCD_p08g') ) |>
    ggplot(  aes(x = mu, y = nmi, group = cons, color = cons)) +
  #geom_smooth() +
  geom_point( size = 1.5) +
  #geom_line( size = 1.0) +

  geom_hline(yintercept = 1.0)+
  #ylim(0.5,1.5)+
  labs(title = "comparing different strategies for outlers", x = "mu", y = " ")+
  theme_light() + #theme(aspect.ratio = 1) + 
  facet_wrap(  ~ alg, scales = 'fixed') +
  theme(aspect.ratio = 1.0)
```

```{r}


row_2_plots <- function(df1, clegend, title){
shapes <- c(6,2,0,21, 21)
colorss <- c("blue","darkgreen","red", "orange", "black")  


p1 <- ggplot(data = df1, aes(x = mu , y = nmi,  shape = cons, color = cons))+
  geom_point(data = df1 %>% filter(cons == 'ST'),size=1, color = "gray")+
  geom_smooth(data = df1 %>% filter(cons != 'ST'), se=FALSE, linewidth = .5)+
  scale_shape_manual(title, values = shapes)+
  scale_color_manual(title, values = colorss)+
  ylim(0.5,1.0)+
  geom_vline(xintercept = 0.5, color = 'red', linetype = "dashed")+
  geom_hline(yintercept = 1, color = 'darkgreen', size = .5, linetype = "dashed")+
  theme_light() + theme(legend.position = 'none') + theme(aspect.ratio = .6)

p2 <- ggplot(data = df1, aes(x = mu , y = nc_norm,  shape = cons, color = cons))+
  geom_point(data = df1 %>% filter(cons == 'ST'), size=1, color = "gray")+
  geom_smooth(data = df1 %>% filter(cons != 'ST'), se=FALSE, linewidth = .5)+
  scale_shape_manual(title, values = shapes)+
  scale_color_manual(title, values = colorss)+
  ylim(0.5,1.0)+
  geom_vline(xintercept = 0.5, color = 'red', linetype = "dashed")+
  geom_hline(yintercept = 1, color = 'darkgreen', linewidth = 0.5, linetype = "dashed")+
  theme_light()  + theme(aspect.ratio = .6)

p3 <- ggplot(data = df1, aes(x = mu, y = mu_emp ,  shape = cons, color = cons))+
 geom_smooth()+
 scale_shape_manual(title, values = shapes)+
 scale_color_manual(title, values = colorss)+
 xlim(0,0.71)+
 geom_abline(slope = 1, intercept = 0, color = 'darkgreen', linewidth = .5, linetype = "dashed")+
 geom_segment(x =0, xend = 0.5, y = 0.5, yend = 0.5, color = "red", linetype = "dashed")+
 geom_segment(x =0.5, xend = 0.5, y = 0, yend = 0.5, color = "red", linetype = "dashed")+
 theme_light() + theme(aspect.ratio = .6)

p <- ggarrange(p1,p2, ncol = 2,common.legend = TRUE, legend="top")+ theme(aspect.ratio =.8)
p <- ggarrange(p1,p2,p3, ncol = 3,common.legend = TRUE, legend="top")+ theme(aspect.ratio = .3)
 

#p <- annotate_figure(p, top = text_grob(title, color = "black",   size = 14))
return(p)
}



```


```{r}
row_2_plots(df %>% filter(alg %in% c('LV')), clegend = T,  title = "algorithm: LV")
row_2_plots(df %>% filter(alg %in% c('LD')), clegend = F , title = "algorithm: LD")
row_2_plots(df %>% filter(alg %in% c('LP')), clegend = F , title = "algorithm: LP")
row_2_plots(df %>% filter(alg %in% c('IM')), clegend = F , title = "algorithm: IM")
row_2_plots(df %>% filter(alg %in% c('WT')), clegend = F , title = "algorithm: WT")
```
 


 
```{r}
df1<-df |>
  select(mu, alg, cons, nmi, nc_norm) |>
  filter(cons %in% c('CCD_p06', 'CCD_p08', 'CCD_p08g') ) |>
  pivot_longer(cols = -c(mu, alg, cons), 
                 names_to = "variable", 
                 values_to = "value")|>
  group_by(mu, alg, cons, variable)|>
    summarize(
    v_mean = mean(value),
    v_lower_quantile = quantile(value, 0.20),
    v_upper_quantile = quantile(value, 0.80)
  )

p_ncnorm <- df1 %>% filter(variable == "nc_norm")|>
  ggplot(aes(x = mu, y = v_mean, group = interaction(alg, cons), color = cons)) +
  geom_hline(yintercept = 1.0)+  
  geom_point() +  
  geom_ribbon(
    aes(ymin = v_lower_quantile, ymax = v_upper_quantile, fill = cons),
    alpha = 0.2,
    color = NA)+
  geom_errorbar(aes(ymin = v_lower_quantile, ymax = v_upper_quantile),width = 0.0) +
  facet_wrap(vars(alg), nrow = 5,  scales = "free_y")+   
  theme_light() + 
  theme(aspect.ratio = .6) +
  theme(legend.position="left")+ 
  labs( x = "mu", y = "number of communities (normalized) k/k0")

p_ncnorm
ggsave("figure_LFR_perf_ncnorm.png", plot = p_ncnorm,  bg = "white", width = 10,  height = 20, units = 'cm', dpi = 300)

```


```{r}
library(png)
library(grid)
#arrange_plots <- grid.arrange(p_ncnorm, p_nmi, nrow = 1)
#arrange_plots
#ggsave("figure_LFR_performance.png", plot = arrange_plots, width = 10, height = 30, units = 'cm', dpi = 300)

# Read the images
image1 <- readPNG("figure_LFR_perf_ncnorm.png")
image2 <- readPNG("figure_LFR_perf_nmi.png")

# Plot the images using grid.arrange with specified widths
pp<-grid.arrange(
  rasterGrob(image1),  
  rasterGrob(image2),    ncol = 2
)
ggsave("figure_LFR_performance.png", plot = pp, width = 25, height = 30, units = 'cm', dpi = 300)

```

# uncertain nodes


```{r}
df2<-df %>% 
  select(mu,mu_bi_int, mu_emp, alg, cons,nmi, uncertain_nodes, uncertainty_q50, uncertainty_q10, uncertainty_q90) 

  
plot1 <- df2 %>% filter(cons %in% c("CCD_p08g"))%>% 
  ggplot(aes(x = mu_bi_int, group = interaction(alg, cons), color = cons)) +
  geom_line(aes(y = uncertain_nodes, color = cons)) +  
  facet_wrap(vars(alg), ncol = 5,  scales = "fixed",labeller = purrr::partial(label_both, sep = " = "))+   
  theme_light() +
  theme(aspect.ratio = 1.0) +  
  #guides(shape = FALSE) +
  theme(legend.position="none") + 
  labs(#title = "fraction of nodes with uncertainty > 0 "
       x = "mixing parameter",
       y = "uncertain nodes") +
  theme(
    #panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    axis.line = element_line(color = "black", size = 0.5),  # Set axis line color and size
    axis.text = element_text(color = "black"),  # Set axis text color
    strip.background = element_rect(fill = "white"),  # Set background color for facet labels
    strip.text = element_text(color = "black")  # Set color for facet labels
  )


plot1
#ggsave("figure_LFR_uncert_nodes.png", plot = plot1, height = 5, units = 'cm', dpi = 300)


```

```{r}
df2<-df %>% 
  select(mu,mu_bi_int, mu_emp, alg, cons,nmi, uncertain_nodes, uncertainty_q50, uncertainty_q10, uncertainty_q90) %>%
  filter(uncertainty_q10>0)%>%
  filter(uncertainty_q50>0)%>%
  filter(uncertainty_q90>0)%>%
  group_by(mu_bi_int, alg, cons)%>%
    summarize(
    unc_10 = mean(uncertainty_q10, na.rm = TRUE),
    unc_50 = mean(uncertainty_q50, na.rm = TRUE),
    unc_90 = mean(uncertainty_q90, na.rm = TRUE),
  )

  
plot2 <- df2 %>% filter(cons %in% c("CCD_p08g"))%>% 
  ggplot(aes(x = mu_bi_int, group = interaction(alg, cons), color = cons)) +
  geom_line(aes(y = unc_50, color = cons)) +  
  geom_ribbon(aes(ymin = unc_10, ymax = unc_90, fill = cons),alpha = 0.2, color = NA)+
  geom_hline(yintercept = 0.6)+
  facet_wrap(vars(alg), ncol = 5,  scales = "fixed",labeller = purrr::partial(label_both, sep = " = "))+   
  theme_light() +
  theme(aspect.ratio = 1.0) +  
  #guides(shape = FALSE) +
  theme(legend.position="none") + 
  labs(#title = "fraction of nodes with uncertainty > 0 "
       x = "mixing parameter",
       y = "uncertainty") +
  theme(
    #panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    axis.line = element_line(color = "black", size = 0.5),  # Set axis line color and size
    axis.text = element_text(color = "black"),  # Set axis text color
    strip.background = element_rect(fill = "white"),  # Set background color for facet labels
    strip.text = element_text(color = "black")  # Set color for facet labels
  )

plot2
#ggsave("figure_LFR_uncert_coeff.png", plot = plot2, height = 5, units = 'cm', dpi = 300)

```

```{r}
arrange_plots <- grid.arrange(plot1, plot2, ncol = 1)
arrange_plots
ggsave("figure_LFR_uncertainty.png", plot = arrange_plots, height = 12, units = 'cm', dpi = 300)

```




 
